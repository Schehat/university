!SESSION 2021-09-18 10:21:13.514 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\Schehat\eclipse-workspace\.metadata\.bak_0.log
Created Time: 2021-09-18 10:21:26.451

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:21:26.452
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:21:26.452
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@93f15f6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5034681f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:21:33.355
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 567 2021-09-18 10:24:48.150
!MESSAGE The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 4 567 2021-09-18 10:24:56.629
!MESSAGE The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-09-18 10:29:28.609 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:29:35.124
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:29:35.124
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e47aab,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@261a66b8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:29:41.617
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 10:34:33.413 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2021-09-18 10:34:53.610
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.610
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.612
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.612
!MESSAGE Could not read metadata for '0.Demo'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/0.Demo)[567]: java.lang.Exception: The project description file (.project) for '0.Demo' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.613
!MESSAGE The project description file (.project) for '0.Demo' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '0.Demo' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.614
!MESSAGE Could not read metadata for '0.Test'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/0.Test)[567]: java.lang.Exception: The project description file (.project) for '0.Test' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.614
!MESSAGE The project description file (.project) for '0.Test' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '0.Test' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.616
!MESSAGE Could not read metadata for '10. UE'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/10. UE)[567]: java.lang.Exception: The project description file (.project) for '10. UE' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.617
!MESSAGE The project description file (.project) for '10. UE' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '10. UE' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.618
!MESSAGE Could not read metadata for '12. Iterative Lösung von LGS'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/12. Iterative Lösung von LGS)[567]: java.lang.Exception: The project description file (.project) for '12. Iterative Lösung von LGS' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.619
!MESSAGE The project description file (.project) for '12. Iterative Lösung von LGS' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '12. Iterative Lösung von LGS' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.621
!MESSAGE Could not read metadata for 'Ab.12'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Ab.12)[567]: java.lang.Exception: The project description file (.project) for 'Ab.12' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.621
!MESSAGE The project description file (.project) for 'Ab.12' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Ab.12' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.622
!MESSAGE Could not read metadata for 'AuD'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/AuD)[567]: java.lang.Exception: The project description file (.project) for 'AuD' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.623
!MESSAGE The project description file (.project) for 'AuD' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'AuD' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.624
!MESSAGE Could not read metadata for 'U02'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/U02)[567]: java.lang.Exception: The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 10:34:53.624
!MESSAGE The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:34:57.988
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:34:57.988
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49fe0bcd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3516b881,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:35:09.574
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 567 2021-09-18 10:38:31.987
!MESSAGE The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'U02' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 4 567 2021-09-18 10:39:10.933
!MESSAGE The project description file (.project) for '12. Iterative Lösung von LGS' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '12. Iterative Lösung von LGS' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 4 567 2021-09-18 10:40:14.975
!MESSAGE The project description file (.project) for 'AuD' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'AuD' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-09-18 10:42:23.771 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data C:\Users\Schehat\eclipse-workspace -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:42:31.819
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:42:31.819
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@71468613,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13f4048e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:42:41.004
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.help.base 2 0 2021-09-18 10:43:07.250
!MESSAGE Unable to consume Lucene index from bundle 'org.eclipse.jdt.doc.user_3.15.1100.v20210531-1101 [216]'. The index should be rebuilt with Lucene 8.4.1

!ENTRY org.eclipse.help.base 2 0 2021-09-18 10:43:07.260
!MESSAGE Unable to consume Lucene index from bundle 'org.eclipse.platform.doc.user_4.20.0.v20210530-2150 [335]'. The index should be rebuilt with Lucene 8.4.1
!SESSION 2021-09-18 10:50:26.265 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -data C:\Users\Schehat\university -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:50:33.410
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:50:33.410
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2e426dd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1a0ffb9b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:50:44.998
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 10:51:16.372 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -data C:\Users\Schehat\university -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:51:23.869
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:51:23.869
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1a0ffb9b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67c0c90b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:51:30.379
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 10:53:15.222 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:53:22.696
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:53:22.697
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@319aa9ee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1d806de6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:53:29.555
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 10:53:48.400 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data C:\Users\Schehat\university -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:53:55.135
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:53:55.135
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8549c5f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35454c7a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:54:02.317
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 10:56:19.614 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data C:\Users\Schehat\eclipse-workspace -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 10:56:27.008
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 10:56:27.009
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35454c7a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50f3ba6a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 10:56:33.722
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 2 2 2021-09-18 11:24:55.488
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2021-09-18 11:24:55.489
!MESSAGE The project description file (.project) for 'U16' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2021-09-18 11:24:55.489
!MESSAGE The project description file (.project) for 'U25' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.

!ENTRY org.eclipse.core.resources 2 2 2021-09-18 11:43:27.615
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2021-09-18 11:43:27.615
!MESSAGE The project description file (.project) for 'Altklausur_2018' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2021-09-18 11:43:27.615
!MESSAGE The project description file (.project) for 'U16' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2021-09-18 11:43:27.615
!MESSAGE The project description file (.project) for 'U25' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.

!ENTRY org.eclipse.core.resources 4 567 2021-09-18 11:43:29.098
!MESSAGE The project description file (.project) for '3. UE' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '3. UE' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 2 2 2021-09-18 11:45:44.740
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2021-09-18 11:45:44.741
!MESSAGE The project description file (.project) for 'Altklausur_2018' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SESSION 2021-09-18 11:54:23.825 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2021-09-18 11:54:27.209
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-09-18 11:54:27.209
!MESSAGE Could not read metadata for 'Altklausur_2018'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Altklausur_2018)[567]: java.lang.Exception: The project description file (.project) for 'Altklausur_2018' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-09-18 11:54:27.210
!MESSAGE The project description file (.project) for 'Altklausur_2018' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Altklausur_2018' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)

!ENTRY org.eclipse.jface 2 0 2021-09-18 11:54:30.851
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 11:54:30.851
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@644947ee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25421809,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 11:54:37.965
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 11:55:37.591 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 11:55:44.401
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 11:55:44.401
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 11:55:53.161
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 11:56:50.321 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 11:56:59.160
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 11:56:59.160
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 11:57:09.613
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 12:06:34.887 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-18 12:06:41.798
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 12:06:41.799
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@430d3021,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 12:06:50.688
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-18 12:14:23.078 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product C:\Users\Schehat\university\prog2\3_ue\u03\src\Individual.java
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product C:\Users\Schehat\university\prog2\3_ue\u03\src\Individual.java

!ENTRY org.eclipse.jface 2 0 2021-09-18 12:14:30.615
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-18 12:14:30.615
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-18 12:14:37.071
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-27 14:45:26.096 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-27 14:45:46.924
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-27 14:45:46.925
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17befef0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5072e638,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-27 14:45:57.721
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-01 18:21:04.400 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-01 18:21:31.410
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-01 18:21:31.410
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-01 18:21:47.664
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-01 18:41:43.762 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-01 18:41:54.477
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-01 18:41:54.477
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-01 18:42:03.083
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.epp.mpc.ui 1 0 2021-10-01 18:49:01.198
!MESSAGE Performing Marketplace install request from http://marketplace.eclipse.org/marketplace-client-intro?mpc_install=335225
!SESSION 2021-10-01 18:56:51.161 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data file:/C:/Users/Schehat/university/ -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-01 18:57:11.478
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-01 18:57:11.478
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1c79d093,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@746fd19b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-01 18:57:24.495
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-01 19:19:40.737 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2021-10-01 19:19:47.657
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-10-01 19:19:47.657
!MESSAGE Could not read metadata for 'test'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/test)[567]: java.lang.Exception: The project description file (.project) for 'test' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-10-01 19:19:47.659
!MESSAGE The project description file (.project) for 'test' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'test' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)

!ENTRY org.eclipse.jface 2 0 2021-10-01 19:19:52.153
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-01 19:19:52.153
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3b8d2abe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6669cba,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-01 19:20:04.764
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-15 14:45:44.807 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data C:\Users\Schehat\university -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-15 14:45:54.752
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-15 14:45:54.752
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5cf072ea,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1edac3b4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-15 14:46:07.677
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 567 2021-10-15 14:49:35.485
!MESSAGE The project description file (.project) for 'test' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'test' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 4 567 2021-10-15 14:50:49.385
!MESSAGE The project description file (.project) for 'Altklausur_2018' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Altklausur_2018' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-10-15 14:54:43.107 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -data C:\Users\Schehat\university -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-15 14:54:54.479
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-15 14:54:54.479
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2059f785,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@18ca9277,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-15 14:55:06.251
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-16 13:25:15.789 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-16 13:26:00.794
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-16 13:26:00.794
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56d5460f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@57f725b8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-16 13:26:11.287
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.eclemma.core 4 5013 2021-10-16 13:31:38.845
!MESSAGE Error while dumping coverage data (code 5013).
!STACK 0
java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:981)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/java.io.FilterInputStream.read(FilterInputStream.java:82)
	at org.jacoco.core.data.ExecutionDataReader.read(ExecutionDataReader.java:84)
	at org.eclipse.eclemma.internal.core.MemoryExecutionDataSource.readFrom(MemoryExecutionDataSource.java:69)
	at org.eclipse.eclemma.internal.core.launching.AgentServer.run(AgentServer.java:115)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-10-16 19:45:47.343 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-16 19:45:58.691
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-16 19:45:58.692
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34652065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-16 19:46:09.995
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-17 13:19:22.286 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-17 13:20:00.383
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-17 13:20:00.383
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d88c1bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-17 13:20:11.838
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-10-17 13:42:41.147
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        HBox hboxTop = new HBox();
        Label lblDeathCounter = new Label("DEATH COUNTER:\n0");
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        
        HBox hboxBottom = new HBox();
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, canvas, player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        Level.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = true;
            
            // surprise! Mainly for debugging purposes skip level
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                Level.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            currentLevel = level;
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            Level.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    
    /**
     * handles selection of game loop per level & necessary editing before running the level
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        btnLevel2.setDisable(true);
        btnLevel3.setDisable(true);
        btnLevel4.setDisable(true);
        btnLevel5.setDisable(true);
        btnLevel6.setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (maxLevel >= 2)  btnLevel2.setDisable(false);
        if (maxLevel >= 3)  btnLevel3.setDisable(false);
        if (maxLevel >= 4)  btnLevel4.setDisable(false);
        if (maxLevel >= 5)  btnLevel5.setDisable(false);
        if (maxLevel >= 6)  btnLevel6.setDisable(false);
                
        if (currentLevel == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
            
            // clear canvas when switching between levels
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        }
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (leftKeyPressed) {
            // rect blue left
            if (player.getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(player);
            }
            // rect white bottom & top left
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH
                        || player.getY() < rectBlueY
                    ) && player.getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(player);
            }
        }
        
        if (rightKeyPressed) {
            // red rect right
            if (player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(player);
            }
            // rect white bottom & top right
            if (
                    (
                        player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH)
                        || 
                        (player.getY() > rectWhiteY 
                        && player.getY() < rectBlueY)
                    )
                    &&
                    player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(player);
            }
        }
        
        if (upKeyPressed) {
            // blue rect top
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(player);
            }
            // white rect top
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(player);
            }
            // red rect top
            if (player.getX() + player.getImage().getWidth() > rectRedX 
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(player);
            }
        }
        
        if (downKeyPressed) {
            // blue rect bottom
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(player);
            }
            // white rect bottom
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() + Controller.getSpeed() 
                    + player.getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(player);
            }
            // red rect bottom
            if (player.getX() + player.getImage().getWidth() > rectRedX  
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(player);
            }
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 2;
            Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);   
            btnLevel2.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {      
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 3;
            Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);   
            btnLevel3.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 325.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 200.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 4;
            Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            btnLevel4.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 375.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 150.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 5;
            Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            btnLevel5.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 200.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 325.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 6;
            Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            btnLevel6.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 150.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 375.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-17 13:42:41.150
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-17 13:42:41.152
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-17 13:42:42.182
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        HBox hboxTop = new HBox();
        Label lblDeathCounter = new Label("DEATH COUNTER:\n0");
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        
        HBox hboxBottom = new HBox();
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, canvas, player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        Level.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = true;
            
            // surprise! Mainly for debugging purposes skip level
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                Level.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            currentLevel = level;
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            Level.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    
    /**
     * handles selection of game loop per level & necessary editing before running the level
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        btnLevel2.setDisable(true);
        btnLevel3.setDisable(true);
        btnLevel4.setDisable(true);
        btnLevel5.setDisable(true);
        btnLevel6.setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (maxLevel >= 2)  btnLevel2.setDisable(false);
        if (maxLevel >= 3)  btnLevel3.setDisable(false);
        if (maxLevel >= 4)  btnLevel4.setDisable(false);
        if (maxLevel >= 5)  btnLevel5.setDisable(false);
        if (maxLevel >= 6)  btnLevel6.setDisable(false);
                
        if (currentLevel == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
            
            // clear canvas when switching between levels
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        }
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (leftKeyPressed) {
            // rect blue left
            if (player.getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(player);
            }
            // rect white bottom & top left
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH
                        || player.getY() < rectBlueY
                    ) && player.getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(player);
            }
        }
        
        if (rightKeyPressed) {
            // red rect right
            if (player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(player);
            }
            // rect white bottom & top right
            if (
                    (
                        player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH)
                        || 
                        (player.getY() > rectWhiteY 
                        && player.getY() < rectBlueY)
                    )
                    &&
                    player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(player);
            }
        }
        
        if (upKeyPressed) {
            // blue rect top
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(player);
            }
            // white rect top
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(player);
            }
            // red rect top
            if (player.getX() + player.getImage().getWidth() > rectRedX 
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(player);
            }
        }
        
        if (downKeyPressed) {
            // blue rect bottom
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(player);
            }
            // white rect bottom
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() + Controller.getSpeed() 
                    + player.getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(player);
            }
            // red rect bottom
            if (player.getX() + player.getImage().getWidth() > rectRedX  
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(player);
            }
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 2;
            Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);   
            btnLevel2.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {      
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 3;
            Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);   
            btnLevel3.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 325.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 200.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 4;
            Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            btnLevel4.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 375.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 150.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 5;
            Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            btnLevel5.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 200.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 325.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 6;
            Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            btnLevel6.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 150.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 375.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-17 13:42:42.184
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-17 13:42:42.184
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-17 13:42:46.211
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        HBox hboxTop = new HBox();
        Label lblDeathCounter = new Label("DEATH COUNTER:\n0");
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        
        HBox hboxBottom = new HBox();
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, canvas, player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        Level.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = true;
            
            // surprise! Mainly for debugging purposes skip level
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                Level.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            currentLevel = level;
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            Level.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    
    /**
     * handles selection of game loop per level & necessary editing before running the level
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        btnLevel2.setDisable(true);
        btnLevel3.setDisable(true);
        btnLevel4.setDisable(true);
        btnLevel5.setDisable(true);
        btnLevel6.setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (maxLevel >= 2)  btnLevel2.setDisable(false);
        if (maxLevel >= 3)  btnLevel3.setDisable(false);
        if (maxLevel >= 4)  btnLevel4.setDisable(false);
        if (maxLevel >= 5)  btnLevel5.setDisable(false);
        if (maxLevel >= 6)  btnLevel6.setDisable(false);
                
        if (currentLevel == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
            
            // clear canvas when switching between levels
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        }
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (leftKeyPressed) {
            // rect blue left
            if (player.getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(player);
            }
            // rect white bottom & top left
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH
                        || player.getY() < rectBlueY
                    ) && player.getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(player);
            }
        }
        
        if (rightKeyPressed) {
            // red rect right
            if (player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(player);
            }
            // rect white bottom & top right
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH)
                        || 
                        (player.getY() > rectWhiteY 
                        && player.getY() < rectBlueY)
                    )
                    &&
                    player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(player);
            }
        }
        
        if (upKeyPressed) {
            // blue rect top
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(player);
            }
            // white rect top
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(player);
            }
            // red rect top
            if (player.getX() + player.getImage().getWidth() > rectRedX 
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(player);
            }
        }
        
        if (downKeyPressed) {
            // blue rect bottom
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(player);
            }
            // white rect bottom
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() + Controller.getSpeed() 
                    + player.getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(player);
            }
            // red rect bottom
            if (player.getX() + player.getImage().getWidth() > rectRedX  
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(player);
            }
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 2;
            Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);   
            btnLevel2.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {      
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 3;
            Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);   
            btnLevel3.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 325.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 200.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 4;
            Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            btnLevel4.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 375.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 150.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 5;
            Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            btnLevel5.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 200.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 325.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 6;
            Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            btnLevel6.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 150.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 375.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-17 13:42:46.213
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-17 13:42:46.215
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-17 13:42:52.251
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        HBox hboxTop = new HBox();
        Label lblDeathCounter = new Label("DEATH COUNTER:\n0");
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        
        HBox hboxBottom = new HBox();
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, canvas, player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        Level.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = true;
            
            // surprise! Mainly for debugging purposes skip level
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                Level.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            currentLevel = level;
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            Level.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    
    /**
     * handles selection of game loop per level & necessary editing before running the level
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        btnLevel2.setDisable(true);
        btnLevel3.setDisable(true);
        btnLevel4.setDisable(true);
        btnLevel5.setDisable(true);
        btnLevel6.setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (maxLevel >= 2)  btnLevel2.setDisable(false);
        if (maxLevel >= 3)  btnLevel3.setDisable(false);
        if (maxLevel >= 4)  btnLevel4.setDisable(false);
        if (maxLevel >= 5)  btnLevel5.setDisable(false);
        if (maxLevel >= 6)  btnLevel6.setDisable(false);
                
        if (currentLevel == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
            
            // clear canvas when switching between levels
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        }
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (leftKeyPressed) {
            // rect blue left
            if (player.getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(player);
            }
            // rect white bottom & top left
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH
                        || player.getY() < rectBlueY
                    ) && player.getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(player);
            }
        }
        
        if (rightKeyPressed) {
            // red rect right
            if (player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(player);
            }
            // rect white bottom & top right
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH)
                        || (player.getY() > rectWhiteY 
                        && player.getY() < rectBlueY)
                    )
                    &&
                    player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(player);
            }
        }
        
        if (upKeyPressed) {
            // blue rect top
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(player);
            }
            // white rect top
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(player);
            }
            // red rect top
            if (player.getX() + player.getImage().getWidth() > rectRedX 
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(player);
            }
        }
        
        if (downKeyPressed) {
            // blue rect bottom
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(player);
            }
            // white rect bottom
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() + Controller.getSpeed() 
                    + player.getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(player);
            }
            // red rect bottom
            if (player.getX() + player.getImage().getWidth() > rectRedX  
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(player);
            }
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 2;
            Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);   
            btnLevel2.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {      
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 3;
            Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);   
            btnLevel3.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 325.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 200.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 4;
            Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            btnLevel4.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 375.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 150.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 5;
            Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            btnLevel5.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 200.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 325.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 6;
            Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            btnLevel6.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 150.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 375.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-17 13:42:52.253
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-17 13:42:52.256
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-17 13:42:57.294
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        HBox hboxTop = new HBox();
        Label lblDeathCounter = new Label("DEATH COUNTER:\n0");
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        
        HBox hboxBottom = new HBox();
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, canvas, player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        Level.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = true;
            
            // surprise! Mainly for debugging purposes skip level
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                Level.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            currentLevel = level;
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            Level.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    
    /**
     * handles selection of game loop per level & necessary editing before running the level
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        btnLevel2.setDisable(true);
        btnLevel3.setDisable(true);
        btnLevel4.setDisable(true);
        btnLevel5.setDisable(true);
        btnLevel6.setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (maxLevel >= 2)  btnLevel2.setDisable(false);
        if (maxLevel >= 3)  btnLevel3.setDisable(false);
        if (maxLevel >= 4)  btnLevel4.setDisable(false);
        if (maxLevel >= 5)  btnLevel5.setDisable(false);
        if (maxLevel >= 6)  btnLevel6.setDisable(false);
                
        if (currentLevel == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
            
            // clear canvas when switching between levels
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        }
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (leftKeyPressed) {
            // rect blue left
            if (player.getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(player);
            }
            // rect white bottom & top left
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH
                        || player.getY() < rectBlueY
                    ) && player.getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(player);
            }
        }
        
        if (rightKeyPressed) {
            // red rect right
            if (player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(player);
            }
            // rect white bottom & top right
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH)
                        ||  
                        && player.getY() < rectBlueY)
                    )
                    &&
                    player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(player);
            }
        }
        
        if (upKeyPressed) {
            // blue rect top
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(player);
            }
            // white rect top
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(player);
            }
            // red rect top
            if (player.getX() + player.getImage().getWidth() > rectRedX 
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(player);
            }
        }
        
        if (downKeyPressed) {
            // blue rect bottom
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(player);
            }
            // white rect bottom
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() + Controller.getSpeed() 
                    + player.getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(player);
            }
            // red rect bottom
            if (player.getX() + player.getImage().getWidth() > rectRedX  
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(player);
            }
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 2;
            Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);   
            btnLevel2.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {      
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 3;
            Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);   
            btnLevel3.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 325.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 200.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 4;
            Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            btnLevel4.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 375.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 150.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 5;
            Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            btnLevel5.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 200.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 325.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 6;
            Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            btnLevel6.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 150.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 375.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-17 13:42:57.295
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-17 13:42:57.297
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-17 13:43:03.331
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        HBox hboxTop = new HBox();
        Label lblDeathCounter = new Label("DEATH COUNTER:\n0");
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        
        HBox hboxBottom = new HBox();
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, canvas, player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        Level.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = true;
            
            // surprise! Mainly for debugging purposes skip level
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                Level.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            currentLevel = level;
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            Level.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    
    /**
     * handles selection of game loop per level & necessary editing before running the level
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        btnLevel2.setDisable(true);
        btnLevel3.setDisable(true);
        btnLevel4.setDisable(true);
        btnLevel5.setDisable(true);
        btnLevel6.setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (maxLevel >= 2)  btnLevel2.setDisable(false);
        if (maxLevel >= 3)  btnLevel3.setDisable(false);
        if (maxLevel >= 4)  btnLevel4.setDisable(false);
        if (maxLevel >= 5)  btnLevel5.setDisable(false);
        if (maxLevel >= 6)  btnLevel6.setDisable(false);
                
        if (currentLevel == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
            
            // clear canvas when switching between levels
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        }
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (leftKeyPressed) {
            // rect blue left
            if (player.getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(player);
            }
            // rect white bottom & top left
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH
                        || player.getY() < rectBlueY
                    ) && player.getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(player);
            }
        }
        
        if (rightKeyPressed) {
            // red rect right
            if (player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(player);
            }
            // rect white bottom & top right
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH)
                        ||& player.getY() < rectBlueY)
                    )
                    &&
                    player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(player);
            }
        }
        
        if (upKeyPressed) {
            // blue rect top
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(player);
            }
            // white rect top
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(player);
            }
            // red rect top
            if (player.getX() + player.getImage().getWidth() > rectRedX 
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(player);
            }
        }
        
        if (downKeyPressed) {
            // blue rect bottom
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(player);
            }
            // white rect bottom
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() + Controller.getSpeed() 
                    + player.getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(player);
            }
            // red rect bottom
            if (player.getX() + player.getImage().getWidth() > rectRedX  
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(player);
            }
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 2;
            Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);   
            btnLevel2.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {      
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 3;
            Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);   
            btnLevel3.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 325.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 200.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 4;
            Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            btnLevel4.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 375.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 150.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 5;
            Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            btnLevel5.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 200.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 325.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 6;
            Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            btnLevel6.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 150.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 375.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-17 13:43:03.332
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-17 13:43:03.333
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-17 13:43:10.902
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        HBox hboxTop = new HBox();
        Label lblDeathCounter = new Label("DEATH COUNTER:\n0");
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        
        HBox hboxBottom = new HBox();
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, canvas, player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        Level.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = true;
            
            // surprise! Mainly for debugging purposes skip level
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                Level.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            currentLevel = level;
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            Level.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    
    /**
     * handles selection of game loop per level & necessary editing before running the level
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        btnLevel2.setDisable(true);
        btnLevel3.setDisable(true);
        btnLevel4.setDisable(true);
        btnLevel5.setDisable(true);
        btnLevel6.setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (maxLevel >= 2)  btnLevel2.setDisable(false);
        if (maxLevel >= 3)  btnLevel3.setDisable(false);
        if (maxLevel >= 4)  btnLevel4.setDisable(false);
        if (maxLevel >= 5)  btnLevel5.setDisable(false);
        if (maxLevel >= 6)  btnLevel6.setDisable(false);
                
        if (currentLevel == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
            
            // clear canvas when switching between levels
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        }
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (leftKeyPressed) {
            // rect blue left
            if (player.getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(player);
            }
            // rect white bottom & top left
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH
                        || player.getY() < rectBlueY
                    ) && player.getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(player);
            }
        }
        
        if (rightKeyPressed) {
            // red rect right
            if (player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(player);
            }
            // rect white bottom & top right
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH)
                        || player.getY() < rectBlueY)
                    &&
                    player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(player);
            }
        }
        
        if (upKeyPressed) {
            // blue rect top
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(player);
            }
            // white rect top
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(player);
            }
            // red rect top
            if (player.getX() + player.getImage().getWidth() > rectRedX 
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(player);
            }
        }
        
        if (downKeyPressed) {
            // blue rect bottom
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(player);
            }
            // white rect bottom
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() + Controller.getSpeed() 
                    + player.getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(player);
            }
            // red rect bottom
            if (player.getX() + player.getImage().getWidth() > rectRedX  
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(player);
            }
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 2;
            Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);   
            btnLevel2.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {      
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 3;
            Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);   
            btnLevel3.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 325.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 200.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 4;
            Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            btnLevel4.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 375.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 150.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 5;
            Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            btnLevel5.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 200.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 325.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 6;
            Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            btnLevel6.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 150.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 375.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-17 13:43:10.903
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-17 13:43:10.905
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-17 13:43:15.434
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        HBox hboxTop = new HBox();
        Label lblDeathCounter = new Label("DEATH COUNTER:\n0");
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        
        HBox hboxBottom = new HBox();
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, canvas, player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        Level.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = true;
            
            // surprise! Mainly for debugging purposes skip level
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                Level.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT))   leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT))  rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP))      upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN))   downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            currentLevel = level;
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            Level.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    
    /**
     * handles selection of game loop per level & necessary editing before running the level
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        btnLevel2.setDisable(true);
        btnLevel3.setDisable(true);
        btnLevel4.setDisable(true);
        btnLevel5.setDisable(true);
        btnLevel6.setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (maxLevel >= 2)  btnLevel2.setDisable(false);
        if (maxLevel >= 3)  btnLevel3.setDisable(false);
        if (maxLevel >= 4)  btnLevel4.setDisable(false);
        if (maxLevel >= 5)  btnLevel5.setDisable(false);
        if (maxLevel >= 6)  btnLevel6.setDisable(false);
                
        if (currentLevel == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
            
            // clear canvas when switching between levels
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        } else if (currentLevel == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            player.setX(200);
            player.setY(300);
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
            
            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        }
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (leftKeyPressed) {
            // rect blue left
            if (player.getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(player);
            }
            // rect white bottom & top left
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH
                        || player.getY() < rectBlueY
                    ) && player.getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(player);
            }
        }
        
        if (rightKeyPressed) {
            // red rect right
            if (player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(player);
            }
            // rect white bottom & top right
            if (
                    (player.getY() + player.getImage().getHeight() > rectBlueY + rectBlueH)
                        || player.getY() < rectBlueY)
                    && player.getX() + Controller.getSpeed() + player.getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(player);
            }
        }
        
        if (upKeyPressed) {
            // blue rect top
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(player);
            }
            // white rect top
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(player);
            }
            // red rect top
            if (player.getX() + player.getImage().getWidth() > rectRedX 
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(player);
            }
        }
        
        if (downKeyPressed) {
            // blue rect bottom
            if (player.getX() > rectBlueX && player.getX() < rectBlueX + rectBlueW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(player);
            }
            // white rect bottom
            if (player.getX() > rectWhiteX && player.getX() < rectWhiteX + rectWhiteW
                    && player.getY() + Controller.getSpeed() 
                    + player.getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(player);
            }
            // red rect bottom
            if (player.getX() + player.getImage().getWidth() > rectRedX  
                    && player.getX() + player.getImage().getWidth() < rectRedX + rectRedW
                    && player.getY() + Controller.getSpeed() + 
                    player.getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(player);
            }
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 2;
            Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);   
            btnLevel2.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {      
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        Level.checkKeysPressed();
        Level.checkMovementBorder();
        
        if (player.getX() > rectRedX) {
            maxLevel = 3;
            Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);   
            btnLevel3.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 325.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 200.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 4;
            Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            btnLevel4.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 375.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 150.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectRedY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 5;
            Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            btnLevel5.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 200.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 325.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        if (player.getX() > 400) {
            maxLevel = 6;
            Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            btnLevel6.setDisable(false);
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        Level.checkKeysPressed();
        
        double rectBlueX = 50.0;
        double rectBlueY = 150.0;
        double rectBlueW = 100.0; 
        double rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + rectHexBlue, 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        double rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        double rectRedY = 375.0;
        double rectRedW = 100.0; 
        double rectRedH = 75.0;
        gc.setFill(Color.web("0x" + rectHexRed, 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        double rectWhiteX = rectBlueX + rectBlueW;
        double rectWhiteY = rectBlueY;
        double rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        double rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + rectHexWhite, 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-17 13:43:15.435
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-17 13:43:15.437
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-10-17 16:05:43.374 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-17 16:05:55.248
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-17 16:05:55.249
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d88c1bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-17 16:06:08.719
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-18 09:32:37.861 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-18 09:33:20.022
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-18 09:33:20.023
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34652065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-18 09:33:32.319
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-18 19:10:50.169 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-18 19:11:35.462
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-18 19:11:35.462
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34652065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-18 19:11:47.735
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 2 0 2021-10-18 19:42:01.601
!MESSAGE The 'org.eclipse.jdt.ui.JavaAllCompletionProposalComputer' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension took too long to return from the 'computeCompletionProposals()' operation.
!SESSION 2021-10-18 22:24:37.271 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-18 22:24:49.442
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-18 22:24:49.442
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d88c1bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-18 22:25:04.177
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-19 20:49:33.538 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-19 20:50:22.110
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-19 20:50:22.110
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22368ddc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72b10258,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-19 20:50:36.260
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-20 17:27:18.230 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-20 17:27:52.907
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-20 17:27:52.907
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34652065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-20 17:28:02.992
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-21 09:35:21.074 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-21 09:35:58.901
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-21 09:35:58.901
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72b10258,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77ec9fdb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-21 09:36:08.664
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-21 19:07:06.719 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-21 19:07:43.960
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-21 19:07:43.960
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d88c1bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-21 19:07:57.530
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-23 10:29:26.406 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-23 10:30:11.098
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-23 10:30:11.098
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34652065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-23 10:30:23.923
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-23 11:35:05.551 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-23 11:35:16.279
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-23 11:35:16.279
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59b853aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ab90d01,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-23 11:35:26.752
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-23 13:15:38.617 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-23 13:16:00.112
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-23 13:16:00.112
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59b853aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ab90d01,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-23 13:16:18.821
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-10-23 18:49:57.256
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import java.util.ArrayList;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.paint.Color;
import javafx.util.Duration;

/**
 * 
 * @author Schehat
 * handling multiple game loops
 */
public class GameLoopManager {
    private static Canvas canvas = new Canvas(Main.getSize()[0], Main.getSize()[1]);
    private static GraphicsContext gc = canvas.getGraphicsContext2D();
    
    //free form animation defined by KeyFrames and their duration 
    private static Timeline tl1 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl1(gc)));
    private static Timeline tl2 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl2(gc)));
    private static Timeline tl3 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl3(gc)));
    private static Timeline tl4 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl4(gc)));
    private static Timeline tl5 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl5(gc)));
    private static Timeline tl6 = new Timeline(new KeyFrame(Duration.millis(10), e -> runLvl6(gc)));
    
    private static double rectBlueX;
    private static double rectBlueY;
    private static double rectBlueW; 
    private static double rectBlueH;
    private static double rectRedX;
    private static double rectRedY;
    private static double rectRedW; 
    private static double rectRedH;
    private static double rectWhiteX;
    private static double rectWhiteY;
    private static double rectWhiteW; 
    private static double rectWhiteH;
    
    public static String circleColor = "F3EF10"; // yellow
    public static int[] circleSize = {20, 20};  // width & height
    public static ArrayList<ImageView> arrIVCircle = new ArrayList<ImageView>();
    public static int[] enemySize = {30, 30};  // width & height
    public static ArrayList<ImageView> arrIVEnemy = new ArrayList<ImageView>();
    public static ArrayList<Integer> arrIVEnemyMove = new ArrayList<Integer>();
    public static boolean setup = false; // for if statements to run code only once  
    
    public static int maxNeededCircles;
    public static int circlesObtained = 0;
    public static int maxEnemies = 0;
    
    public static double enemyOffsetY;
    public static double enemyOffsetX;
    
    /**
     * handling multiple game loops
     */
    public static void gameLoopManager() {
        // at the start disable all buttons except button 1
        Level.getBtnLevel2().setDisable(true);
        Level.getBtnLevel3().setDisable(true);
        Level.getBtnLevel4().setDisable(true);
        Level.getBtnLevel5().setDisable(true);
        Level.getBtnLevel6().setDisable(true);

        // maxLevel == 1 not needed, should always be not disabled
        if (Level.getMaxLevel() >= 2)  Level.getBtnLevel2().setDisable(false);
        if (Level.getMaxLevel() >= 3)  Level.getBtnLevel3().setDisable(false);
        if (Level.getMaxLevel() >= 4)  Level.getBtnLevel4().setDisable(false);
        if (Level.getMaxLevel() >= 5)  Level.getBtnLevel5().setDisable(false);
        if (Level.getMaxLevel() >= 6)  Level.getBtnLevel6().setDisable(false);
        
        // reset state
        circlesObtained = 0;
        setup = false;
        
        // clear canvas when switching between levels
        gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        
        // clear circles & enemies
        arrIVCircle.clear();
        arrIVEnemy.clear();
        arrIVEnemyMove.clear();
        
        if (Level.getCurrentLevel() == 1) {
            // do not want the game loop of the other level play at background
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            // load circles & enemies
            maxNeededCircles = 2;
            initilizeCircle();
            maxEnemies = 3;
            initilizeEnemy();
            
            //number of cycles in animation INDEFINITE = repeat indefinitely
            tl1.setCycleCount(Timeline.INDEFINITE);
            
            // level switches will not continue where they left, instead start at
            // the beginning again
            tl1.playFromStart();
        } else if (Level.getCurrentLevel() == 2) {         
            tl1.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            maxNeededCircles = 4;
            initilizeCircle();
            maxEnemies = 10;
            initilizeEnemy();
            
            tl2.setCycleCount(Timeline.INDEFINITE);
            tl2.playFromStart();
        } else if (Level.getCurrentLevel() == 3) {     
            tl1.stop();
            tl2.stop();
            tl4.stop();
            tl5.stop();
            tl6.stop();
            
            maxNeededCircles = 3;
            initilizeCircle();
            maxEnemies = 3;
            initilizeEnemy();
            
            tl3.setCycleCount(Timeline.INDEFINITE);
            tl3.playFromStart();
        } else if (Level.getCurrentLevel() == 4) {           
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl5.stop();
            tl6.stop();
           
            maxNeededCircles = 4;
            initilizeCircle();
            maxEnemies = 8;
            initilizeEnemy();
            
            tl4.setCycleCount(Timeline.INDEFINITE);
            tl4.playFromStart();
        } else if (Level.getCurrentLevel() == 5) {   
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl6.stop();
         
            maxNeededCircles = 3;
            initilizeCircle();
            maxEnemies = 6;
            initilizeEnemy();
            
            tl5.setCycleCount(Timeline.INDEFINITE);
            tl5.playFromStart();
        } else if (Level.getCurrentLevel() == 6) {      
            tl1.stop();
            tl2.stop();
            tl3.stop();
            tl4.stop();
            tl5.stop();
            
            maxNeededCircles = 4;
            initilizeCircle();
            maxEnemies = 12;
            initilizeEnemy();
            
            tl6.setCycleCount(Timeline.INDEFINITE);
            tl6.playFromStart();
        }
    }
    
    /**
     * run game loop to animate level environment & enemies of 1st level
     * @param gc
     */
    public static void runLvl1(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + Level.getRectHexBlue(), 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + Level.getRectHexRed(), 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 50;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*50.0;
        gc.setFill(Color.web("0x" + Level.getRectHexWhite(), 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);

        int offsetX = 80;
        // left circle
        arrIVCircle.get(0).setX(rectWhiteX + rectWhiteW/2 - circleSize[0]/2 - offsetX);
        arrIVCircle.get(0).setY(rectWhiteY + rectWhiteH/2 - circleSize[0]/2);
        
        // right circle
        arrIVCircle.get(1).setX(rectWhiteX + rectWhiteW/2 - circleSize[0]/2 + offsetX);
        arrIVCircle.get(1).setY(rectWhiteY + rectWhiteH/2 - circleSize[0]/2);
        
        int xPadding = 75;
        if (setup == false) {
            setPlayerPosition((int) (rectBlueX + rectBlueW/2 - Level.getPlayer().getImage().getWidth()/2), 
                    (int) (rectBlueY + rectBlueH/2 - Level.getPlayer().getImage().getHeight()/2));
            
            enemyOffsetX = (rectWhiteW - enemySize[0]) / (maxEnemies-1) - xPadding;
            enemyOffsetY = (rectWhiteH - enemySize[0]) / (maxEnemies-1);
            for (int i = 0; i < maxEnemies; i++) {
                arrIVEnemy.get(i).setX(rectWhiteX + i*enemyOffsetX + xPadding);
                arrIVEnemy.get(i).setY(rectWhiteY + i*enemyOffsetY);
            }
        }
        
        moveEnemiesVertical(2);
        
        // for some reason not needed to clear before adding when switching between scenes
        addImagesToRoot();
        
        Level.checkKeysPressed();      
        checkMovementBorder();
        checkCollisionCircle();
        checkNextLevel(2);
    }
    
    /**
     * run game loop to animate level environment & enemies of 2nd level
     * @param gc
     */
    public static void runLvl2(GraphicsContext gc) {          
        rectBlueX = 50.0;
        rectBlueY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectBlueW = 100.0; 
        rectBlueH = 100.0;
        gc.setFill(Color.web("0x" + Level.getRectHexBlue(), 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 300.0 - 50.0; // center from canvas 150 to 450 then +- 50 
        rectRedW = 100.0; 
        rectRedH = 100.0;
        gc.setFill(Color.web("0x" + Level.getRectHexRed(), 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY - 100;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueH + 2*100.0;
        gc.setFill(Color.web("0x" + Level.getRectHexWhite(), 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        GameLoopManager.drawCirclesInCorners(10, 10);
        
        if (setup == false) {
            setPlayerPosition((int) (rectBlueX + rectBlueW/2 - Level.getPlayer().getImage().getWidth()/2), 
                    (int) (rectBlueY + rectBlueH/2 - Level.getPlayer().getImage().getHeight()/2));
            
            enemyOffsetX = (rectWhiteW - enemySize[0]) / (maxEnemies-1);
            for (int i = 0; i < maxEnemies; i++) {
                arrIVEnemy.get(i).setX(rectWhiteX + i*enemyOffsetX);
                if (i % 2 == 0) {
                    arrIVEnemy.get(i).setY(rectWhiteY + 0);
                } else {
                    arrIVEnemy.get(i).setY(rectWhiteY + rectWhiteH - enemySize[0]);
                }
            }
        }
        
        moveEnemiesVertical(2);
        
        addImagesToRoot();
        
        Level.checkKeysPressed();
        checkMovementBorder();
        checkCollisionCircle();
        checkNextLevel(3);
    }
    
    /**
     * run game loop to animate level environment & enemies of 3rd level
     * @param gc
     */
    public static void runLvl3(GraphicsContext gc) {
        rectBlueX = 50.0;
        rectBlueY = 325.0;
        rectBlueW = 100.0; 
        rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + Level.getRectHexBlue(), 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 200.0;
        rectRedW = 100.0; 
        rectRedH = 75.0;
        gc.setFill(Color.web("0x" + Level.getRectHexRed(), 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectRedY;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + Level.getRectHexWhite(), 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        GameLoopManager.drawCirclesInDiagonal(0);
        
        int yPadding = 35;
        if (setup == false) {
            setPlayerPosition((int) (rectBlueX + rectBlueW/2 - Level.getPlayer().getImage().getWidth()/2), 
                    (int) (rectBlueY + rectBlueH/2 - Level.getPlayer().getImage().getHeight()/2));
            
            enemyOffsetX = (rectWhiteW - enemySize[0]) / (maxEnemies-1);
            enemyOffsetY = (rectWhiteH - enemySize[0]) / (maxEnemies-1) - yPadding;
            for (int i = 0; i < maxEnemies; i++) {
                arrIVEnemy.get(i).setX(rectWhiteX + i*enemyOffsetX);
                arrIVEnemy.get(i).setY(rectWhiteY + i*enemyOffsetY + yPadding);
            }
        }
        
        moveEnemiesHorizontal(3);
        
        addImagesToRoot();
        
        Level.checkKeysPressed();
        checkMovementBorder();
        checkCollisionCircle();
        checkNextLevel(4);
    }
    
    /**
     * run game loop to animate level environment & enemies of 4th level
     * @param gc
     */
    public static void runLvl4(GraphicsContext gc) {   
        rectBlueX = 50.0;
        rectBlueY = 375.0;
        rectBlueW = 100.0; 
        rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + Level.getRectHexBlue(), 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 150.0;
        rectRedW = 100.0; 
        rectRedH = 75.0;
        gc.setFill(Color.web("0x" + Level.getRectHexRed(), 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectRedY;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectBlueY + rectBlueH - rectRedY;
        gc.setFill(Color.web("0x" + Level.getRectHexWhite(), 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        GameLoopManager.drawCirclesInCorners(50, 50);
        
        if (setup == false) {
            setPlayerPosition((int) (rectBlueX + rectBlueW/2 - Level.getPlayer().getImage().getWidth()/2), 
                    (int) (rectBlueY + rectBlueH/2 - Level.getPlayer().getImage().getHeight()/2));
            
            enemyOffsetY = (rectWhiteH - enemySize[0]) / (maxEnemies-1);
            for (int i = 0; i < maxEnemies; i++) {
                arrIVEnemy.get(i).setY(rectWhiteY + i*enemyOffsetY);
                if (i % 2 == 0) {
                    arrIVEnemy.get(i).setX(rectWhiteX);
                } else {
                    arrIVEnemy.get(i).setX(rectWhiteX + rectWhiteW - enemySize[0]);
                }
            }
        }
        
        moveEnemiesHorizontal(3);
        
        addImagesToRoot();
        
        Level.checkKeysPressed();
        checkMovementBorder();
        checkCollisionCircle();
        checkNextLevel(5);
    }
    
    /**
     * run game loop to animate level environment & enemies of 5th level
     * @param gc
     */
    public static void runLvl5(GraphicsContext gc) {        
        rectBlueX = 50.0;
        rectBlueY = 200.0;
        rectBlueW = 100.0; 
        rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + Level.getRectHexBlue(), 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 325.0;
        rectRedW = 100.0; 
        rectRedH = 75.0;
        gc.setFill(Color.web("0x" + Level.getRectHexRed(), 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + Level.getRectHexWhite(), 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        GameLoopManager.drawCirclesInDiagonal(1);
        
        int verticalEnemies = 3;
        if (setup == false) {
            setPlayerPosition((int) (rectBlueX + rectBlueW/2 - Level.getPlayer().getImage().getWidth()/2), 
                    (int) (rectBlueY + rectBlueH/2 - Level.getPlayer().getImage().getHeight()/2));
            for (int i = 0; i < verticalEnemies; i++) {
                arrIVEnemy.get(i).setX(arrIVCircle.get(i).getX() - circleSize[0]/4);
                /*
                 * should be i % 2 != 0 but first circle is in center thats why doing this
                   for proper position so left & right enemy starts at top and the center enemy at the bottom
                 */
                if (i > 0) {
                    arrIVEnemy.get(i).setY(rectWhiteY);
                } else {
                    arrIVEnemy.get(i).setY(rectWhiteY + rectWhiteH - enemySize[0]);
                }
            }
        }
        ;
        int horizontalEnemies = 3;
        if (setup == false) {
            setPlayerPosition((int) (rectBlueX + rectBlueW/2 - Level.getPlayer().getImage().getWidth()/2), 
                    (int) (rectBlueY + rectBlueH/2 - Level.getPlayer().getImage().getHeight()/2));
            for (int i = horizontalEnemies; i < maxEnemies; i++) {
                arrIVEnemy.get(i).setY(arrIVCircle.get(i - horizontalEnemies).getY() - circleSize[0]/4);
                if (i > horizontalEnemies) {
                    arrIVEnemy.get(i).setX(rectWhiteX);
                } else {
                    arrIVEnemy.get(i).setX(rectWhiteX + rectWhiteW - enemySize[0]);
                }
            }
        }
        
        int speed = 2;
        // movie enemies vertically
        for (int i = 0; i < verticalEnemies; i++) {
            if (arrIVEnemy.get(i).getY() < rectWhiteY || arrIVEnemy.get(i).getY() > rectWhiteY + rectWhiteH - enemySize[0]) {
                arrIVEnemyMove.set(i, -1*arrIVEnemyMove.get(i));
            }
            arrIVEnemy.get(i).setY(arrIVEnemy.get(i).getY() + speed*arrIVEnemyMove.get(i));
        }
        
        speed = 3;
        // movie enemies horizontally
        for (int i = horizontalEnemies; i < maxEnemies; i++) {
            if (arrIVEnemy.get(i).getX() < rectWhiteX || arrIVEnemy.get(i).getX() > rectWhiteX + rectWhiteW - enemySize[0]) {
                arrIVEnemyMove.set(i, -1*arrIVEnemyMove.get(i));
            }
            arrIVEnemy.get(i).setX(arrIVEnemy.get(i).getX() + speed*arrIVEnemyMove.get(i));
        }
        
        addImagesToRoot();
        
        Level.checkKeysPressed();
        checkMovementBorder();
        checkCollisionCircle();
        checkNextLevel(6);
    }
    
    /**
     * run game loop to animate level environment & enemies of 6th level
     * @param gc
     */
    public static void runLvl6(GraphicsContext gc) {
        rectBlueX = 50.0;
        rectBlueY = 150.0;
        rectBlueW = 100.0; 
        rectBlueH = 75.0;
        gc.setFill(Color.web("0x" + Level.getRectHexBlue(), 1.0));
        gc.fillRect(rectBlueX, rectBlueY, rectBlueW, rectBlueH);
        
        rectRedX = Main.getSize()[0] - 2*rectBlueX - rectBlueX;
        rectRedY = 375.0;
        rectRedW = 100.0; 
        rectRedH = 75.0;
        gc.setFill(Color.web("0x" + Level.getRectHexRed(), 1.0));
        gc.fillRect(rectRedX, rectRedY, rectRedW, rectRedH);
        
        rectWhiteX = rectBlueX + rectBlueW;
        rectWhiteY = rectBlueY;
        rectWhiteW = rectRedX - rectBlueX - rectBlueW; 
        rectWhiteH = rectRedY + rectBlueH - rectBlueY;
        gc.setFill(Color.web("0x" + Level.getRectHexWhite(), 1.0));
        gc.fillRect(rectWhiteX, rectWhiteY, rectWhiteW, rectWhiteH);
        
        GameLoopManager.drawCirclesInCorners(80, 80);
        
        int xPadding = 30;
        int verticalEnemies = 4;
        if (setup == false) {
            setPlayerPosition((int) (rectBlueX + rectBlueW/2 - Level.getPlayer().getImage().getWidth()/2), 
                    (int) (rectBlueY + rectBlueH/2 - Level.getPlayer().getImage().getHeight()/2));
            for (int i = 0; i < verticalEnemies; i++) {
                arrIVEnemy.get(i).setX(arrIVCircle.get(i).getX() - circleSize[0]/4 + xPadding);
                /*
                 * should be i % 2 != 0 but first circle is in center thats why doing this
                   for proper position so left & right enemy starts at top and the center enemy at the bottom
                 */
                if (i % 2 == 0) {
                    arrIVEnemy.get(i).setY(rectWhiteY);
                } else {
                    arrIVEnemy.get(i).setY(rectWhiteY + rectWhiteH - enemySize[0]);
                }
            }
        }
        ;
        int horizontalEnemies = 4;
        if (setup == false) {
            for (int i = horizontalEnemies; i < horizontalEnemies + verticalEnemies; i++) {
                arrIVEnemy.get(i).setY(arrIVCircle.get(i - horizontalEnemies).getY() - circleSize[0]/4);
                arrIVEnemy.get(i).setX(arrIVCircle.get(i - horizontalEnemies).getX() - circleSize[0]/4);
            }
        }
        
        // enemies in the center
        if (setup == false) {
                arrIVEnemy.get(8).setX(rectWhiteX + rectWhiteW/2 - enemySize[0]/2);
                arrIVEnemy.get(8).setY(rectWhiteY);
                
                arrIVEnemy.get(9).setX(rectWhiteX + rectWhiteW/2 - enemySize[0]/2);
                arrIVEnemy.get(9).setY(rectWhiteY + rectWhiteH - enemySize[0]/2);
                
                arrIVEnemy.get(10).setX(0);
                arrIVEnemy.get(10).setY(rectWhiteY + rectWhiteH - enemySize[0]/2);
                
                arrIVEnemy.get(11).setX(rectWhiteX + rectWhiteW - enemySize[0]/2);
                arrIVEnemy.get(11).setY(rectWhiteY + rectWhiteH - enemySize[0]/2);
        }
        
        int speed = 2;
        // movie enemies vertically
        for (int i = 0; i < verticalEnemies; i++) {
            if (arrIVEnemy.get(i).getY() < rectWhiteY || arrIVEnemy.get(i).getY() > rectWhiteY + rectWhiteH - enemySize[0]) {
                arrIVEnemyMove.set(i, -1*arrIVEnemyMove.get(i));
            }
            arrIVEnemy.get(i).setY(arrIVEnemy.get(i).getY() + speed*arrIVEnemyMove.get(i));
        }
        
        // special configuration of movement pattern
        if (setup == false ) {
            for (int i = horizontalEnemies; i < horizontalEnemies + verticalEnemies; i++) {
                if (i < horizontalEnemies + 2) {
                    arrIVEnemyMove.set(i, 1);
                } else {
                    arrIVEnemyMove.set(i, -1);
                }
            }   
        }
        
        speed = 3;
        // movie enemies horizontally
        for (int i = horizontalEnemies; i < horizontalEnemies + verticalEnemies; i++) {
            if (arrIVEnemy.get(i).getX() < rectWhiteX || arrIVEnemy.get(i).getX() > rectWhiteX + rectWhiteW - enemySize[0]) {
                arrIVEnemyMove.set(i, -1*arrIVEnemyMove.get(i));
            }
            arrIVEnemy.get(i).setX(arrIVEnemy.get(i).getX() + speed*arrIVEnemyMove.get(i));
        }
        
        // movie enemies which were place in the center
        // vertically
        for ()
        if (arrIVEnemy.get(i).getY() < rectWhiteY || arrIVEnemy.get(i).getY() > rectWhiteY + rectWhiteH - enemySize[0]) {
            arrIVEnemyMove.set(i, -1*arrIVEnemyMove.get(i));
        }
        addImagesToRoot();
        
        Level.checkKeysPressed();
        checkMovementBorder();
        checkCollisionCircle();
    }
    
    /**
     * block players movement at level borders
     */
    public static void checkMovementBorder() {
        if (Level.getLeftKeyPressed()) {
            // rect blue left
            if (Level.getPlayer().getX() - Controller.getSpeed() < rectBlueX) {
                Controller.moveRight(Level.getPlayer());
            }
            // rect white bottom & top left
            if (
                    (Level.getPlayer().getY() + Level.getPlayer().getImage().getHeight() > rectBlueY + rectBlueH
                        || Level.getPlayer().getY() < rectBlueY
                    ) && Level.getPlayer().getX() - Controller.getSpeed() < rectWhiteX) {
                Controller.moveRight(Level.getPlayer());
            }
        }
        
        if (Level.getRightKeyPressed()) {
            // red rect right
            if (Level.getPlayer().getX() + Controller.getSpeed() + Level.getPlayer().getImage().getWidth() 
                    > rectRedX + rectRedW) {
                Controller.moveLeft(Level.getPlayer());
            }
            // rect white bottom & top right
            if (
                    (Level.getPlayer().getY() + Level.getPlayer().getImage().getHeight() > rectRedY + rectRedH
                        || Level.getPlayer().getY() < rectRedY)
                    && Level.getPlayer().getX() + Controller.getSpeed() + Level.getPlayer().getImage().getWidth() 
                    > rectWhiteX + rectWhiteW) {
                Controller.moveLeft(Level.getPlayer());
            }
        }
        
        if (Level.getUpKeyPressed()) {
            // blue rect top
            if (Level.getPlayer().getX() > rectBlueX && Level.getPlayer().getX() < rectBlueX + rectBlueW
                    && Level.getPlayer().getY() - Controller.getSpeed() < rectBlueY) {
                Controller.moveDown(Level.getPlayer());
            }
            // white rect top
            if (Level.getPlayer().getX() > rectWhiteX && Level.getPlayer().getX() < rectWhiteX + rectWhiteW
                    && Level.getPlayer().getY() - Controller.getSpeed() < rectWhiteY) {
                Controller.moveDown(Level.getPlayer());
            }
            // red rect top
            if (Level.getPlayer().getX() + Level.getPlayer().getImage().getWidth() > rectRedX 
                    && Level.getPlayer().getX() + Level.getPlayer().getImage().getWidth() < rectRedX + rectRedW
                    && Level.getPlayer().getY() - Controller.getSpeed() < rectRedY) {
                Controller.moveDown(Level.getPlayer());
            }
        }
        
        if (Level.getDownKeyPressed()) {
            // blue rect bottom
            if (Level.getPlayer().getX() > rectBlueX && Level.getPlayer().getX() < rectBlueX + rectBlueW
                    && Level.getPlayer().getY() + Controller.getSpeed() + 
                    Level.getPlayer().getImage().getHeight()> rectBlueY + rectBlueH) {
                Controller.moveUp(Level.getPlayer());
            }
            // white rect bottom
            if (Level.getPlayer().getX() > rectWhiteX && Level.getPlayer().getX() < rectWhiteX + rectWhiteW
                    && Level.getPlayer().getY() + Controller.getSpeed() 
                    + Level.getPlayer().getImage().getHeight() > rectWhiteY + rectWhiteH) {
                Controller.moveUp(Level.getPlayer());
            }
            // red rect bottom
            if (Level.getPlayer().getX() + Level.getPlayer().getImage().getWidth() > rectRedX  
                    && Level.getPlayer().getX() + Level.getPlayer().getImage().getWidth() < rectRedX + rectRedW
                    && Level.getPlayer().getY() + Controller.getSpeed() + 
                    Level.getPlayer().getImage().getHeight()> rectRedY + rectRedH) {
                Controller.moveUp(Level.getPlayer());
            }
        }
    }
    
    /**
     * 
     * @param offsetX of circle to static x location
     * @param offsetY of circle to static y location
     */
    public static void drawCirclesInCorners(int offsetX, int offsetY) {
        // top left
        arrIVCircle.get(0).setX(rectWhiteX + offsetX);
        arrIVCircle.get(0).setY(rectWhiteY + offsetY);
        
        // bottom left
        arrIVCircle.get(1).setX(rectWhiteX + offsetX);
        arrIVCircle.get(1).setY(rectWhiteY + rectWhiteH - offsetY - circleSize[1]);
        
        // top right
        arrIVCircle.get(2).setX(rectWhiteX + rectWhiteW - offsetX - circleSize[0]);
        arrIVCircle.get(2).setY(rectWhiteY + offsetY);
        
        // bottom right
        arrIVCircle.get(3).setX(rectWhiteX + rectWhiteW - offsetX - circleSize[0]);
        arrIVCircle.get(3).setY(rectWhiteY + rectWhiteH - offsetY - circleSize[1]);
    }
    
    /**
     * draws circles in correct position for the level
     * @param direction, 0: from bottom left to top right & 1: from top left to bottom right
     */
    public static void drawCirclesInDiagonal(int direction) {
        gc.setFill(Color.web("0x" + circleColor, 1.0));
        int offsetX = 125, offsetY = 75;
        
        // center
        arrIVCircle.get(0).setX(rectWhiteX + rectWhiteW/2 - circleSize[0]/2);
        arrIVCircle.get(0).setY(rectWhiteY + rectWhiteH/2 - circleSize[0]/2);
        
        if (direction == 0) {
            // left
            arrIVCircle.get(1).setX(rectWhiteX + rectWhiteW/2 - circleSize[0]/2 - offsetX);
            arrIVCircle.get(1).setY(rectWhiteY + rectWhiteH/2 - circleSize[0]/2 + offsetY);
            
            // right
            arrIVCircle.get(2).setX(rectWhiteX + rectWhiteW/2 - circleSize[0]/2 + offsetX);
            arrIVCircle.get(2).setY(rectWhiteY + rectWhiteH/2 - circleSize[0]/2 - offsetY);
        } else {
            // left
            arrIVCircle.get(1).setX(rectWhiteX + rectWhiteW/2 - circleSize[0]/2 - offsetX);
            arrIVCircle.get(1).setY(rectWhiteY + rectWhiteH/2 - circleSize[0]/2 - offsetY);
            
            // right
            arrIVCircle.get(2).setX(rectWhiteX + rectWhiteW/2 - circleSize[0]/2 + offsetX);
            arrIVCircle.get(2).setY(rectWhiteY + rectWhiteH/2 - circleSize[0]/2 + offsetY);
        }
    }
    
    /**
     * check collision between player & circles and player & enemies
     */
    public static void checkCollisionCircle() {
        for (int i = 0; i < maxNeededCircles; i++) {
            // when not checking weather circle in root then collision still works at the background
            if (Level.getRoot().getChildren().contains(arrIVCircle.get(i))) {
                if (Level.getPlayer().getImageView().getBoundsInParent().intersects(arrIVCircle.get(i).getBoundsInParent())) {
                    Level.getRoot().getChildren().remove(arrIVCircle.get(i));
                    circlesObtained++;
                }
            }
        }
        
        for (int i = 0; i < maxEnemies; i++) {
            if (Level.getRoot().getChildren().contains(arrIVEnemy.get(i))) {
                if (Level.getPlayer().getImageView().getBoundsInParent().intersects(arrIVEnemy.get(i).getBoundsInParent())) {
                    setPlayerPosition((int) (rectBlueX + rectBlueW/2 - Level.getPlayer().getImage().getWidth()/2), 
                            (int) (rectBlueY + rectBlueH/2 - Level.getPlayer().getImage().getHeight()/2));
                }
            }
        }
    }
    
    /**
     * 
     * @return canvas
     */
    public static Canvas getCanvas() {
        return canvas;
    }
    
    /**
     * add circle images to array object to display them later
     */
    public static void initilizeCircle() {
        for (int i = 0; i < maxNeededCircles; i++ ) {
            arrIVCircle.add(new ImageView(new Image("circle.png")));
        }
    }
    
    /**
     * add enemy images to array object to display them later
     */
    public static void initilizeEnemy() {
        int sign = 1;
        for (int i = 0; i < maxEnemies; i++ ) {
            arrIVEnemy.add(new ImageView(new Image("smith.png")));
            arrIVEnemyMove.add(sign);
            sign*= -1;
        }
    }
    
    /**
     * checks weather next level should be unlocked, meaning the button is 
     */
    public static void checkNextLevel(int nextLevel) {
        if (Level.getPlayer().getX() > rectRedX && circlesObtained == maxNeededCircles) {
            Level.setMaxLevel(nextLevel);
            if (nextLevel == 2) {
                Level.setBtn(Level.getBtnLevel2(), Level.getBtnLevel2().getText(), Level.getBtnHexBlue());
                Level.getBtnLevel2().setDisable(false);
            } else if (nextLevel == 3) {
                Level.setBtn(Level.getBtnLevel3(), Level.getBtnLevel3().getText(), Level.getBtnHexBlue());
                Level.getBtnLevel3().setDisable(false);
            } else if (nextLevel == 4) {
                Level.setBtn(Level.getBtnLevel4(), Level.getBtnLevel4().getText(), Level.getBtnHexBlue());
                Level.getBtnLevel4().setDisable(false);
            }  else if (nextLevel == 5) {
                Level.setBtn(Level.getBtnLevel5(), Level.getBtnLevel5().getText(), Level.getBtnHexBlue());
                Level.getBtnLevel5().setDisable(false);
            }  else if (nextLevel == 6) {
                Level.setBtn(Level.getBtnLevel6(), Level.getBtnLevel6().getText(), Level.getBtnHexBlue());
                Level.getBtnLevel6().setDisable(false);
            }
        }
    }
    
    /**
     * add circles & enemies to root to be seen
     */
    public static void addImagesToRoot() {
        if (setup == false) {
            for (int i = 0; i < maxNeededCircles; i++) {
                    Level.getRoot().getChildren().add(arrIVCircle.get(i));
            }
            for (int i = 0; i < maxEnemies; i++) {
                Level.getRoot().getChildren().add(arrIVEnemy.get(i));
            }
            setup = true;
        }
    }
    
    /**
     * stops all timelines to allow smooth scene switches when clicking the back button
     */
    public static void stopAllTimelines() {
        tl1.stop();
        tl2.stop();
        tl3.stop();
        tl4.stop();
        tl5.stop();
        tl6.stop();
    }
    
    /**
     * moving enemies vertically in the level
     * @param speed
     */
    public static void moveEnemiesVertical(double speed) {
        for (int i = 0; i < maxEnemies; i++) {
            if (arrIVEnemy.get(i).getY() < rectWhiteY || arrIVEnemy.get(i).getY() > rectWhiteY + rectWhiteH - enemySize[0]) {
                arrIVEnemyMove.set(i, -1*arrIVEnemyMove.get(i));
            }
            arrIVEnemy.get(i).setY(arrIVEnemy.get(i).getY() + speed*arrIVEnemyMove.get(i));
        }
    }
    
    /**
     * moving enemies horizontally in the level
     * @param speed
     */
    public static void moveEnemiesHorizontal(double speed) {
        for (int i = 0; i < maxEnemies; i++) {
            if (arrIVEnemy.get(i).getX() < rectWhiteX || arrIVEnemy.get(i).getX() > rectWhiteX + rectWhiteW - enemySize[0]) {
                arrIVEnemyMove.set(i, -1*arrIVEnemyMove.get(i));
            }
            arrIVEnemy.get(i).setX(arrIVEnemy.get(i).getX() + speed*arrIVEnemyMove.get(i));
        }
    }
    
    /**
     * set player position
     * @param x
     * @param y
     */
    public static void setPlayerPosition(int x, int y) {
        Level.getPlayer().setX(x);
        Level.getPlayer().setY(y);
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2664)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2025)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3647)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2185)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-23 18:49:57.261
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2664)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2025)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3647)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2185)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-23 18:49:57.262
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2664)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2025)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3647)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2185)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-23 19:18:38.841
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static HBox hboxTop = new HBox();
    private static HBox hboxBottom = new HBox();
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static int deathCounter = 0;
    private static Label lblDeathCounter = new Label("DEATH COUNTER:\n" + deathCounter);
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        hboxTop.getChildren().clear();
        hboxBottom.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, GameLoopManager.getCanvas(), player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        GameLoopManager.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT) || e.getCode().equals(KeyCode.A)) leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT) || e.getCode().equals(KeyCode.D))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP) || e.getCode().equals(KeyCode.W)) upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN) || e.getCode().equals(KeyCode.S)) downKeyPressed = true;
            
            // Mainly for debugging purposes skipping levels
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                clearRoot();
                GameLoopManager.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT) || e.getCode().equals(KeyCode.A)) leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT) || e.getCode().equals(KeyCode.D)) rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP) || e.getCode().equals(KeyCode.W)) upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN) || e.getCode().equals(KeyCode.S)) downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            GameLoopManager.stopAllTimelines();
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            currentLevel = level;
            
            // to reset Layout & remove enemies from previous level
            clearRoot();
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            
            GameLoopManager.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * 
     * @return btnLevel2
     */
    public static Button getBtnLevel2() {
        return btnLevel2;
    }
    
    /**
     * 
     * @return btnLevel3
     */
    public static Button getBtnLevel3() {
        return btnLevel3;
    }
    
    /**
     * 
     * @return btnLevel4
     */
    public static Button getBtnLevel4() {
        return btnLevel4;
    }
    
    /**
     * 
     * @return btnLevel5
     */
    public static Button getBtnLevel5() {
        return btnLevel5;
    }
    
    /**
     * 
     * @return btnLevel6
     */
    public static Button getBtnLevel6() {
        return btnLevel6;
    }
    
    /**
     * 
     * @return maxLevel
     */
    public static int getMaxLevel() {
        return maxLevel;
    }
    
    /**
     * 
     * @return currentLevel
     */
    public static int getCurrentLevel() {
        return currentLevel;
    }
    
    /**
     * 
     * @return player
     */
    public static Player getPlayer() {
        return player;
    }
    
    /**
     * 
     * @return rectHexBlue
     */
    public static String getRectHexBlue() {
        return rectHexBlue;
    }
    
    /**
     * 
     * @return rectHexWhite
     */
    public static String getRectHexWhite() {
        return rectHexWhite;
    }
    
    /**
     * 
     * @return rectHexRed
     */
    public static String getRectHexRed() {
        return rectHexRed;
    }
    
    /**
     * 
     * @return btnHexBlue
     */
    public static String getBtnHexBlue() {
        return btnHexBlue;
    }
    
    /**
     * 
     * @return btnHexGreen
     */
    public static String getBtnHexGreen() {
        return btnHexGreen;
    }
    
    /**
     * 
     * @return btnHexRed
     */
    public static String getBtnHexRed() {
        return btnHexRed;
    }
    
    /**
     * 
     * @return leftKeyPressed
     */
    public static boolean getLeftKeyPressed() {
        return leftKeyPressed;
    }
    
    /**
     * 
     * @return rightKeyPressed
     */
    public static boolean getRightKeyPressed() {
        return rightKeyPressed;
    }
    
    /**
     * 
     * @return upKeyPressed
     */
    public static boolean getUpKeyPressed() {
        return upKeyPressed;
    }
    
    /**
     * 
     * @return downKeyPressed
     */
    public static boolean getDownKeyPressed() {
        return downKeyPressed;
    }
    
    /**
     * set maxLevel
     * @param max
     */
    public static void setMaxLevel(int max) {
        maxLevel = max;
    }
    
    /**
     * 
     * @return root BorderPane which the main node in the level
     */
    public static BorderPane getRoot() {
        return root;
    }
    
    /**
     * reset root to avoid problems when switching between scenes
     */
    public static void clearRoot() {
        root.getChildren().clear();
        root.getChildren().addAll(iVBg, GameLoopManager.getCanvas(), player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
    }
    
    
    /**
     * increment death counter 
     * @return deathCounter 
     */
    public static void incrementDeathCounter() {
        deathCounter++;
        deathCounterLaebl Label("DEATH COUNTER:\n" + deathCounter)
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-23 19:18:38.844
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-23 19:18:38.845
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-23 19:18:40.361
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static HBox hboxTop = new HBox();
    private static HBox hboxBottom = new HBox();
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static int deathCounter = 0;
    private static Label lblDeathCounter = new Label("DEATH COUNTER:\n" + deathCounter);
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        hboxTop.getChildren().clear();
        hboxBottom.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, GameLoopManager.getCanvas(), player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        GameLoopManager.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT) || e.getCode().equals(KeyCode.A)) leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT) || e.getCode().equals(KeyCode.D))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP) || e.getCode().equals(KeyCode.W)) upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN) || e.getCode().equals(KeyCode.S)) downKeyPressed = true;
            
            // Mainly for debugging purposes skipping levels
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                clearRoot();
                GameLoopManager.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT) || e.getCode().equals(KeyCode.A)) leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT) || e.getCode().equals(KeyCode.D)) rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP) || e.getCode().equals(KeyCode.W)) upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN) || e.getCode().equals(KeyCode.S)) downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            GameLoopManager.stopAllTimelines();
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            currentLevel = level;
            
            // to reset Layout & remove enemies from previous level
            clearRoot();
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            
            GameLoopManager.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * 
     * @return btnLevel2
     */
    public static Button getBtnLevel2() {
        return btnLevel2;
    }
    
    /**
     * 
     * @return btnLevel3
     */
    public static Button getBtnLevel3() {
        return btnLevel3;
    }
    
    /**
     * 
     * @return btnLevel4
     */
    public static Button getBtnLevel4() {
        return btnLevel4;
    }
    
    /**
     * 
     * @return btnLevel5
     */
    public static Button getBtnLevel5() {
        return btnLevel5;
    }
    
    /**
     * 
     * @return btnLevel6
     */
    public static Button getBtnLevel6() {
        return btnLevel6;
    }
    
    /**
     * 
     * @return maxLevel
     */
    public static int getMaxLevel() {
        return maxLevel;
    }
    
    /**
     * 
     * @return currentLevel
     */
    public static int getCurrentLevel() {
        return currentLevel;
    }
    
    /**
     * 
     * @return player
     */
    public static Player getPlayer() {
        return player;
    }
    
    /**
     * 
     * @return rectHexBlue
     */
    public static String getRectHexBlue() {
        return rectHexBlue;
    }
    
    /**
     * 
     * @return rectHexWhite
     */
    public static String getRectHexWhite() {
        return rectHexWhite;
    }
    
    /**
     * 
     * @return rectHexRed
     */
    public static String getRectHexRed() {
        return rectHexRed;
    }
    
    /**
     * 
     * @return btnHexBlue
     */
    public static String getBtnHexBlue() {
        return btnHexBlue;
    }
    
    /**
     * 
     * @return btnHexGreen
     */
    public static String getBtnHexGreen() {
        return btnHexGreen;
    }
    
    /**
     * 
     * @return btnHexRed
     */
    public static String getBtnHexRed() {
        return btnHexRed;
    }
    
    /**
     * 
     * @return leftKeyPressed
     */
    public static boolean getLeftKeyPressed() {
        return leftKeyPressed;
    }
    
    /**
     * 
     * @return rightKeyPressed
     */
    public static boolean getRightKeyPressed() {
        return rightKeyPressed;
    }
    
    /**
     * 
     * @return upKeyPressed
     */
    public static boolean getUpKeyPressed() {
        return upKeyPressed;
    }
    
    /**
     * 
     * @return downKeyPressed
     */
    public static boolean getDownKeyPressed() {
        return downKeyPressed;
    }
    
    /**
     * set maxLevel
     * @param max
     */
    public static void setMaxLevel(int max) {
        maxLevel = max;
    }
    
    /**
     * 
     * @return root BorderPane which the main node in the level
     */
    public static BorderPane getRoot() {
        return root;
    }
    
    /**
     * reset root to avoid problems when switching between scenes
     */
    public static void clearRoot() {
        root.getChildren().clear();
        root.getChildren().addAll(iVBg, GameLoopManager.getCanvas(), player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
    }
    
    
    /**
     * increment death counter 
     * @return deathCounter 
     */
    public static void incrementDeathCounter() {
        deathCounter++;
        deathCounterLaebl.set Label("DEATH COUNTER:\n" + deathCounter)
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-23 19:18:40.363
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-23 19:18:40.365
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-23 19:18:41.383
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package application;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;

/**
 * 
 * @author Schehat
 * configuration of the first level in the game
 */
public class Level {
    private static Stage stage;
    private static BorderPane root = new BorderPane();
    private static Scene scene = new Scene(root, Main.getSize()[0], Main.getSize()[1]);
    private static HBox hboxTop = new HBox();
    private static HBox hboxBottom = new HBox();
    private static Player player = new Player("neo");
    private static Image iBg = new Image("background.gif");
    private static ImageView iVBg = new ImageView(iBg);
    private static Image iMorpheus = new Image("morpheus_small.png");
    private static ImageView iVMorpheus = new ImageView(iMorpheus);
    private static Image iInstructions = new Image("instructions.png");
    private static ImageView iVInstructions = new ImageView(iInstructions);
    
    private static int deathCounter = 0;
    private static Label lblDeathCounter = new Label("DEATH COUNTER:\n" + deathCounter);
    private static Button btnBack= new Button(); 
    private static Button btnLevel1 = new Button();
    private static Button btnLevel2 = new Button();     
    private static Button btnLevel3 = new Button();  
    private static Button btnLevel4 = new Button();  
    private static Button btnLevel5 = new Button();  
    private static Button btnLevel6 = new Button();  
    
    private static int btnPrefWidth = 100;
    private static int btnPrefHeight = 35;
    private static String btnTextLevel = "LEVEL";
    private static String btnBackYellow = "#E9DD25";
    private static String btnHexRed = "#C75A41";
    private static String btnHexBlue = "#415FC7";
    private static String btnHexGreen = "#47D92B";
    private static String btnBorderWidth = "2px";
    private static String btnBorderColor = "#000000"; 
    private static String btnFontSize = "20px";
    private static String btnBorderRadius = "6px";
    
    private static int currentLevel = 1;
    private static int maxLevel = 1;  // to track the highest level the player can play
    private static String rectHexWhite = "F3F5F6";
    private static String rectHexRed = "C75A41";
    private static String rectHexBlue = "415FC7";
    
    private static boolean leftKeyPressed = false;
    private static boolean rightKeyPressed = false;
    private static boolean upKeyPressed = false;
    private static boolean downKeyPressed = false;
    
    /**
     * create level layout
     */
    public static void setLayout() {        
        root.getChildren().clear();
        hboxTop.getChildren().clear();
        hboxBottom.getChildren().clear();
        
        iVBg.setX(0.0);
        iVBg.setY(0.0);
        
        Level.setBtn(btnBack, "BACK", btnBackYellow);
        Level.setBtn(btnLevel1, btnTextLevel + " 1", btnHexGreen);
        Level.setBtn(btnLevel2, btnTextLevel + " 2", btnHexRed);
        Level.setBtn(btnLevel3, btnTextLevel + " 3", btnHexRed);
        Level.setBtn(btnLevel4, btnTextLevel + " 4", btnHexRed);
        Level.setBtn(btnLevel5, btnTextLevel + " 5", btnHexRed);
        Level.setBtn(btnLevel6, btnTextLevel + " 6", btnHexRed);
        
        lblDeathCounter.setFont(new Font("Arial", 18));
        // to not wrap text with ... sign
        lblDeathCounter.setMinWidth(170);
        lblDeathCounter.setTextFill(Color.WHITE);
        hboxTop.getChildren().addAll(iVMorpheus, iVInstructions, lblDeathCounter);
        hboxTop.setSpacing(10.0);
        hboxTop.setPadding(new Insets(30));
        hboxTop.setAlignment(Pos.CENTER);
        
        hboxBottom.getChildren().addAll(btnBack, btnLevel1, btnLevel2, btnLevel3, 
                                            btnLevel4, btnLevel5, btnLevel6);
        hboxBottom.setSpacing(10.0);
        hboxBottom.setPadding(new Insets(30));
        hboxBottom.setAlignment(Pos.CENTER);
              
        root.getChildren().addAll(iVBg, GameLoopManager.getCanvas(), player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
        
        GameLoopManager.gameLoopManager();
    }
    
    /**
     * set properties of buttons & css styling
     * @param btn
     * @param text
     * @param bgColor
     */
    public static void setBtn(Button btn, String text, String bgColor) {
        btn.setText(text);
        btn.setMaxWidth(btnPrefWidth);
        btn.setMaxHeight(btnPrefHeight);
      
        btn.setStyle("-fx-border-width: " + btnBorderWidth + "; "
                  + "-fx-border-color: " + btnBorderColor + "; "
                  + "-fx-font-size: " + btnFontSize + "; "
                  + "-fx-background-color: " + bgColor + "; "
                  + "-fx-border-radius: " + btnBorderRadius + ";");
    }
    
    /**
     * set up all events in the first level
     */
    public static void setEvents() {
        scene.setOnKeyPressed(e -> {
            if (e.getCode().equals(KeyCode.LEFT) || e.getCode().equals(KeyCode.A)) leftKeyPressed = true; 
            if (e.getCode().equals(KeyCode.RIGHT) || e.getCode().equals(KeyCode.D))  rightKeyPressed = true;
            if(e.getCode().equals(KeyCode.UP) || e.getCode().equals(KeyCode.W)) upKeyPressed = true;
            if (e.getCode().equals(KeyCode.DOWN) || e.getCode().equals(KeyCode.S)) downKeyPressed = true;
            
            // Mainly for debugging purposes skipping levels
            if (e.getCode().equals(KeyCode.N)) {
                maxLevel = 6;
                clearRoot();
                GameLoopManager.gameLoopManager();
            }
        });
        
        scene.setOnKeyReleased(e -> {
            if (e.getCode().equals(KeyCode.LEFT) || e.getCode().equals(KeyCode.A)) leftKeyPressed = false; 
            if (e.getCode().equals(KeyCode.RIGHT) || e.getCode().equals(KeyCode.D)) rightKeyPressed = false;
            if(e.getCode().equals(KeyCode.UP) || e.getCode().equals(KeyCode.W)) upKeyPressed = false;
            if (e.getCode().equals(KeyCode.DOWN) || e.getCode().equals(KeyCode.S)) downKeyPressed = false;
        });
        
        btnBack.setOnMouseEntered(e -> scene.setCursor(Cursor.HAND));
        btnBack.setOnMouseExited(e -> scene.setCursor(Cursor.DEFAULT));
        btnBack.setOnAction(e -> {
            GameLoopManager.stopAllTimelines();
            StartScene.setLayout();
            stage.setScene(StartScene.getScene());
        });
        
        Level.setButtonEvents(btnLevel1, 1);
        Level.setButtonEvents(btnLevel2, 2);
        Level.setButtonEvents(btnLevel3, 3);
        Level.setButtonEvents(btnLevel4, 4);
        Level.setButtonEvents(btnLevel5, 5);
        Level.setButtonEvents(btnLevel6, 6);
    }
    
    /**
     * set events for buttons
     * @param btn
     * @param level
     */
    public static void setButtonEvents(Button btn, int level) {
        btn.setOnAction(e -> {
            Level.setBtn(btn, btn.getText(), btnHexGreen);
            
            currentLevel = level;
            
            // to reset Layout & remove enemies from previous level
            clearRoot();
            
            // change green colored button to blue
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexBlue);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexBlue);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexBlue);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexBlue);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexBlue);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexBlue);
            }
            
            // if green button clicked again then it will turn blue
            // thats why after setting new level state need to 
            // turn the button to green color again
            if (currentLevel == 1) {
                Level.setBtn(btnLevel1, btnLevel1.getText(), btnHexGreen);
            } else if (currentLevel == 2) {
                Level.setBtn(btnLevel2, btnLevel2.getText(), btnHexGreen);
            } else if (currentLevel == 3) {
                Level.setBtn(btnLevel3, btnLevel3.getText(), btnHexGreen);
            } else if (currentLevel == 4) {
                Level.setBtn(btnLevel4, btnLevel4.getText(), btnHexGreen);
            } else if (currentLevel == 5) {
                Level.setBtn(btnLevel5, btnLevel5.getText(), btnHexGreen);
            } else if (currentLevel == 6) {
                Level.setBtn(btnLevel6, btnLevel6.getText(), btnHexGreen);
            }
            
            GameLoopManager.gameLoopManager();
        });
        
        btn.setOnMouseEntered(e -> {
            // this if statement at the end not necessary due to 
            // only buttons which are not disabled allow events 
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.HAND);
            }
        });
        
        btn.setOnMouseExited(e -> {
            if (!btn.isDisabled()) {
                scene.setCursor(Cursor.DEFAULT);
            }
        });
    }
    
    /**
     * 
     * @return scene of Level
     */
    public static Scene getScene() {
        return Level.scene;
    }
    
    /**
     * to customize scene need current stage
     * @param stage
     */
    public static void setStage(Stage stage) {
        Level.stage = stage;
    }
    
    /**
     * if keys pressed move player according to the pressed key
     */
    public static void checkKeysPressed() {
        if (leftKeyPressed) Controller.moveLeft(player);
        if (rightKeyPressed) Controller.moveRight(player);
        if (upKeyPressed) Controller.moveUp(player);
        if (downKeyPressed) Controller.moveDown(player);
    }
    
    /**
     * 
     * @return btnLevel2
     */
    public static Button getBtnLevel2() {
        return btnLevel2;
    }
    
    /**
     * 
     * @return btnLevel3
     */
    public static Button getBtnLevel3() {
        return btnLevel3;
    }
    
    /**
     * 
     * @return btnLevel4
     */
    public static Button getBtnLevel4() {
        return btnLevel4;
    }
    
    /**
     * 
     * @return btnLevel5
     */
    public static Button getBtnLevel5() {
        return btnLevel5;
    }
    
    /**
     * 
     * @return btnLevel6
     */
    public static Button getBtnLevel6() {
        return btnLevel6;
    }
    
    /**
     * 
     * @return maxLevel
     */
    public static int getMaxLevel() {
        return maxLevel;
    }
    
    /**
     * 
     * @return currentLevel
     */
    public static int getCurrentLevel() {
        return currentLevel;
    }
    
    /**
     * 
     * @return player
     */
    public static Player getPlayer() {
        return player;
    }
    
    /**
     * 
     * @return rectHexBlue
     */
    public static String getRectHexBlue() {
        return rectHexBlue;
    }
    
    /**
     * 
     * @return rectHexWhite
     */
    public static String getRectHexWhite() {
        return rectHexWhite;
    }
    
    /**
     * 
     * @return rectHexRed
     */
    public static String getRectHexRed() {
        return rectHexRed;
    }
    
    /**
     * 
     * @return btnHexBlue
     */
    public static String getBtnHexBlue() {
        return btnHexBlue;
    }
    
    /**
     * 
     * @return btnHexGreen
     */
    public static String getBtnHexGreen() {
        return btnHexGreen;
    }
    
    /**
     * 
     * @return btnHexRed
     */
    public static String getBtnHexRed() {
        return btnHexRed;
    }
    
    /**
     * 
     * @return leftKeyPressed
     */
    public static boolean getLeftKeyPressed() {
        return leftKeyPressed;
    }
    
    /**
     * 
     * @return rightKeyPressed
     */
    public static boolean getRightKeyPressed() {
        return rightKeyPressed;
    }
    
    /**
     * 
     * @return upKeyPressed
     */
    public static boolean getUpKeyPressed() {
        return upKeyPressed;
    }
    
    /**
     * 
     * @return downKeyPressed
     */
    public static boolean getDownKeyPressed() {
        return downKeyPressed;
    }
    
    /**
     * set maxLevel
     * @param max
     */
    public static void setMaxLevel(int max) {
        maxLevel = max;
    }
    
    /**
     * 
     * @return root BorderPane which the main node in the level
     */
    public static BorderPane getRoot() {
        return root;
    }
    
    /**
     * reset root to avoid problems when switching between scenes
     */
    public static void clearRoot() {
        root.getChildren().clear();
        root.getChildren().addAll(iVBg, GameLoopManager.getCanvas(), player.getImageView());
        root.setTop(hboxTop);
        root.setBottom(hboxBottom);
    }
    
    
    /**
     * increment death counter 
     * @return deathCounter 
     */
    public static void incrementDeathCounter() {
        deathCounter++;
        deathCounterLaebl.set Label("DEATH COUNTER:\n" + deathCounter)
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-23 19:18:41.384
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-23 19:18:41.385
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-10-25 08:24:49.145 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-25 08:25:35.619
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-25 08:25:35.619
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3636f2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34652065,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-25 08:25:54.262
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-26 11:06:04.713 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-26 11:06:44.669
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-26 11:06:44.669
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@771d4db,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d88c1bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-26 11:06:56.995
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-26 11:17:25.837 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product C:\Users\Schehat\Downloads\uebung5-vorlage\src\de\hsh\dbs2\imdb\Starter.java
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product C:\Users\Schehat\Downloads\uebung5-vorlage\src\de\hsh\dbs2\imdb\Starter.java

!ENTRY org.eclipse.jface 2 0 2021-10-26 11:17:36.061
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-26 11:17:36.061
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42cd0fc6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e5864c2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-26 11:17:48.057
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-26 11:42:52.103 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-26 11:43:40.826
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-26 11:43:40.826
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@432eb882,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69372c1e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-26 11:43:56.595
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-26 19:42:43.104 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-26 19:42:51.005
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-26 19:42:51.005
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35af1558,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2361365c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-26 19:42:57.814
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-27 07:31:10.818 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-27 07:31:51.483
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-27 07:31:51.483
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@146add7b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22368ddc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-27 07:32:00.717
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-27 08:59:05.559 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-27 08:59:16.416
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-27 08:59:16.416
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77ec9fdb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35af1558,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-27 08:59:27.548
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-27 11:57:56.817 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-27 11:58:33.094
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-27 11:58:33.094
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@771d4db,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d88c1bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-27 11:58:42.457
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-28 16:20:48.151 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-28 16:21:39.532
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-28 16:21:39.532
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@771d4db,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d88c1bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-28 16:21:54.105
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-28 22:20:17.319 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-28 22:21:15.358
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-28 22:21:15.358
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35af1558,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2361365c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-28 22:21:26.787
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.launching 4 4 2021-10-28 22:28:14.373
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist
!STACK 1
Java Model Exception: Java Model Status [Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1630)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.refreshStatus(LaunchConfigurationsDialog.java:1331)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refreshStatus(LaunchConfigurationTabGroupViewer.java:1117)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.lambda$4(LaunchConfigurationTabGroupViewer.java:738)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.inputChanged(LaunchConfigurationTabGroupViewer.java:742)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.setInput0(LaunchConfigurationTabGroupViewer.java:674)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.setInput(LaunchConfigurationTabGroupViewer.java:654)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.handleLaunchConfigurationSelectionChanged(LaunchConfigurationsDialog.java:1049)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.lambda$1(LaunchConfigurationsDialog.java:612)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:823)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:820)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1193)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:263)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:258)
	at org.eclipse.jface.util.OpenStrategy$1.lambda$1(OpenStrategy.java:428)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 22:28:14.374
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2021-10-28 22:28:14.381
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist
!STACK 1
Java Model Exception: Java Model Status [Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTabGroup.performApply(AbstractLaunchConfigurationTabGroup.java:106)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupWrapper.performApply(LaunchConfigurationTabGroupWrapper.java:205)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.handleApplyPressed(LaunchConfigurationTabGroupViewer.java:1503)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.handleLaunchConfigurationSelectionChanged(LaunchConfigurationsDialog.java:1051)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.lambda$1(LaunchConfigurationsDialog.java:612)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:823)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:820)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1193)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:263)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:258)
	at org.eclipse.jface.util.OpenStrategy$1.lambda$1(OpenStrategy.java:428)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 22:28:14.382
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2021-10-28 22:28:14.406
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist
!STACK 1
Java Model Exception: Java Model Status [Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.handleLaunchConfigurationSelectionChanged(LaunchConfigurationsDialog.java:1056)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.lambda$1(LaunchConfigurationsDialog.java:612)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:823)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:820)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1193)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:263)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:258)
	at org.eclipse.jface.util.OpenStrategy$1.lambda$1(OpenStrategy.java:428)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 22:28:14.407
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2021-10-28 22:28:14.533
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist
!STACK 1
Java Model Exception: Java Model Status [Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab$1.runInUIThread(AbstractLaunchConfigurationTab.java:513)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 22:28:14.533
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2021-10-28 22:28:14.547
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist
!STACK 1
Java Model Exception: Java Model Status [Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab$1.runInUIThread(AbstractLaunchConfigurationTab.java:513)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 22:28:14.548
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2021-10-28 22:28:14.565
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist
!STACK 1
Java Model Exception: Java Model Status [Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab$1.runInUIThread(AbstractLaunchConfigurationTab.java:513)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 22:28:14.565
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2021-10-28 22:28:14.596
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist
!STACK 1
Java Model Exception: Java Model Status [Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab$1.runInUIThread(AbstractLaunchConfigurationTab.java:513)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 22:28:14.596
!MESSAGE Main1 [in Main1.java [in <default> [in src [in U22]]]] does not exist
!SESSION 2021-10-29 12:43:06.913 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-29 12:43:53.182
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-29 12:43:53.182
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22368ddc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72b10258,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-29 12:44:06.110
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-29 14:48:48.286 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-29 14:49:08.751
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-29 14:49:08.751
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59b853aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ab90d01,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-29 14:49:19.914
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-29 17:17:15.743 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-29 17:17:25.657
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-29 17:17:25.657
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35af1558,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2361365c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-29 17:17:33.180
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-29 21:31:13.692 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-29 21:31:47.401
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-29 21:31:47.401
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2361365c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59b853aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-29 21:31:56.058
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-30 11:45:05.281 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-30 11:45:41.504
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-30 11:45:41.504
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59b853aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ab90d01,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-30 11:45:52.206
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-31 14:36:17.587 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=de_DE
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-31 14:37:06.150
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-31 14:37:06.150
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24842b8e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@146add7b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-31 14:37:22.021
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Schehat'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2021-10-31 16:16:43.213
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.swt.widgets.Display.getClickCount(int, int, long, long)" because "this.display" is null
	at org.eclipse.swt.widgets.Widget.sendMouseEvent(Widget.java:1100)
	at org.eclipse.swt.widgets.Widget.wmMouseMove(Widget.java:2103)
	at org.eclipse.swt.widgets.Control.WM_MOUSEMOVE(Control.java:5328)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4807)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
